<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>My Shop</title>
    <link rel="icon" href="https://cdn.jsdelivr.net/gh/twitter/twemoji@14.0.2/assets/72x72/1f3ea.png" type="image/png">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <link rel="stylesheet" href="https://unpkg.com/swiper/swiper-bundle.min.css" />
    <link rel="stylesheet" href="styles.css">

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-2L0WH445YK"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());

        gtag('config', 'G-2L0WH445YK');
    </script>
</head>

<body>
    <div id="app" v-cloak>
        <header-component page-type="index">
        </header-component>


        <main class="main-content">
            <div v-if="isLoading || isProcessingOrder" class="loading-overlay">
                <div class="spinner"></div>
            </div>

            <!-- Carousel -->
            <div class="swiper-container main-carousel">
                <div class="swiper-wrapper">
                    <div class="swiper-slide" v-for="(image, index) in getCarouselImages" :key="index">
                        <img :src="image.url" class="carousel-image">
                    </div>
                </div>
                <!-- Add Pagination -->
                <div class="swiper-pagination"></div>
                <!-- Add Navigation -->
                <div class="swiper-button-next"></div>
                <div class="swiper-button-prev"></div>
            </div>

            <div class="container">
                <div class="products">
                    <div class="products-main-header">
                        <h2>{{ $t('productList') }}</h2>
                        <div class="products-main-header-buttons">
                            <button @click="openModal('orderHistory')">{{ $t('viewOrderHistory') }}</button>
                            <button @click="openModal('productManagement')">{{
                                $t('productManagement') }}</button>
                            <button @click="openModal('carouselManagement')">{{
                                $t('manageCarousel') }}</button>
                        </div>
                    </div>

                    <div class="products-list">
                        <div v-for="product in filteredProducts" :key="product.id" class="product-card"
                            :class="{ deleted: product.deleted }" itemscope itemtype="http://schema.org/Product">
                            <div class="product-header">
                                <h3 itemprop="name">{{ product.name }}</h3>
                            </div>
                            <div v-if="product.images && product.images.length > 0" class="product-media-container">
                                <div class="swiper-container product-swiper-container"
                                    :class="'product-swiper-' + product.id">
                                    <div class="swiper-wrapper">
                                        <div class="swiper-slide" v-for="(media, index) in product.images" :key="index">
                                            <template v-if="getMediaType(media) === 'image'">
                                                <img :src="media" alt="Product Image">
                                            </template>
                                            <template v-else-if="getMediaType(media) === 'video'">
                                                <div class="video-container" style="position: relative;">
                                                    <video :src="media" muted loop playsinline autoplay
                                                        class="product-video"></video>
                                                    <button @click="toggleMute($event)" class="mute-btn material-icons">
                                                        volume_off
                                                    </button>
                                                </div>
                                            </template>
                                            <template v-else-if="getMediaType(media) === 'youtube'">
                                                <div class="youtube-container">
                                                    <iframe :src="getYouTubeEmbedUrl(media)" frameborder="0"
                                                        allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
                                                        allowfullscreen></iframe>
                                                </div>
                                            </template>
                                        </div>
                                    </div>
                                </div>
                                <div class="swiper-pagination" :class="'product-pagination-' + product.id"></div>
                            </div>
                            <div v-else class="no-image-placeholder">
                                {{ $t('noImageAvailable') }}
                            </div>
                            <div itemprop="offers" itemscope itemtype="http://schema.org/Offer">
                                <p>{{ $t('price') }}: <span itemprop="price">{{ formattedPrice(product.price) }}</span>
                                </p>
                                <meta itemprop="priceCurrency" content="TWD" />
                            </div>
                            <p>{{ $t('stock') }}: <span itemprop="inventoryLevel">{{ product.stock }}</span></p>
                            <div itemprop="brand" itemscope itemtype="http://schema.org/Brand">
                                <p>{{ $t('brand') }}: <span itemprop="name">{{ product.brand || 'N/A' }}</span></p>
                            </div>
                            <div itemprop="aggregateRating" itemscope itemtype="http://schema.org/AggregateRating">
                                <p>
                                    {{ $t('rating') }}: <span itemprop="ratingValue">{{
                                        getAverageRating(product.id).toFixed(1) }}</span>
                                    (<span itemprop="reviewCount">{{ getProductReviews(product.id).length }}</span> {{
                                    $t('reviewCountText') }})
                                </p>
                            </div>
                            <div class="review-button-wrapper">
                                <button @click="openModal('productReviews', { product: product })"
                                    class="view-reviews-btn">
                                    <i class="material-icons">reviews</i>
                                </button>
                            </div>
                            <p>{{ $t('sold') }}: {{ product.soldQuantity }}</p>
                            <button @click="addToCart(product)" :disabled="product.stock === 0" class="add-to-cart-btn">
                                <i class="material-icons">add_shopping_cart</i>
                                <span>{{ $t('addToCart') }}</span>
                            </button>
                        </div>
                    </div>
                </div>

                <div class="cart">
                    <h2>{{ $t('cart') }}</h2>
                    <button v-if="cart.length > 0" @click="clearCart" class="remove-btn clear-cart-btn">{{
                        $t('clearCart') }}</button>
                    <div v-if="isAddingToEmptyCart" class="loading-overlay cart-loading-overlay">
                        <div class="spinner cart-spinner"></div>
                    </div>
                    <div v-if="cart.length === 0" class="empty-cart cart-content">
                        {{ $t('cartEmpty') }}
                    </div>
                    <div v-else class="cart-content">
                        <div class="cart-items-container">
                            <div v-for="item in cart" :key="item.id" class="cart-item">
                                <div>
                                    <strong>{{ item.name }}</strong>
                                    <br>
                                    <br>
                                    <small>{{ formattedPrice(item.price) }}</small>
                                </div>
                                <div class="quantity-controls">
                                    <button @click="updateQuantity(item, -1)">-</button>
                                    <span>{{ item.quantity }}</span>
                                    <button @click="updateQuantity(item, 1)">+</button>
                                </div>
                                <div>
                                    <button @click="removeFromCart(item.id)" class="icon-button remove-btn">
                                        <i class="material-icons">delete</i>
                                    </button>
                                </div>
                            </div>
                        </div>
                        <div class="cart-summary">
                            <div class="cart-summary-row">
                                <span>{{ $t('totalQuantity') }}:</span>
                                <span>{{ totalQuantity }}</span>
                            </div>
                            <div class="cart-summary-row">
                                <span>{{ $t('total') }}</span>
                                <span>{{ formattedPrice(cartTotal) }}</span>
                            </div>
                            <button @click="startCheckout" :disabled="cart.length === 0" class="checkout-btn">{{
                                $t('checkout') }}</button>
                        </div>
                    </div>
                </div>
            </div>

            <div v-if="currentModal && currentModal.name === 'checkout'" class="modal-overlay"
                :style="{ zIndex: getModalZIndex(modalStack.indexOf(currentModal)) }">
                <div class="modal-content">
                    <div class="modal-header">
                        <button @click="closeModal()" class="close-button" v-if="modalStack.length > 1"><i
                                class="material-icons">arrow_back</i></button>
                        <h2>{{ $t('checkout') }}</h2>
                        <button @click="closeModal()" class="close-button">&times;</button>
                    </div>
                    <div class="modal-body">
                        <h3>{{ $t('checkoutSummary') }}</h3>
                        <ul>
                            <li v-for="item in cart" :key="item.id">
                                {{ item.name }} x {{ item.quantity }} - {{ formattedPrice(item.price * item.quantity) }}
                            </li>
                        </ul>
                        <p><strong>{{ $t('total') }}: {{ formattedPrice(cartTotal) }}</strong></p>

                        <h3>{{ $t('choosePaymentMethod') }}</h3>
                        <div class="payment-methods">
                            <label class="payment-method-label">
                                <input type="radio" v-model="paymentMethod" value="credit_card"> {{ $t('creditCard') }}
                            </label>
                            <label class="payment-method-label">
                                <input type="radio" v-model="paymentMethod" value="line_pay"> {{ $t('linePay') }}
                            </label>
                            <label>
                                <input type="radio" v-model="paymentMethod" value="cash"> {{ $t('cash') }}
                            </label>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button @click="processCheckout">{{ $t('confirmCheckout') }}</button>
                        <button @click="closeModal()" class="remove-btn">{{ $t('cancel') }}</button>
                    </div>
                </div>
            </div>

            <div v-if="currentModal && currentModal.name === 'orderConfirmation'" class="modal-overlay"
                :style="{ zIndex: getModalZIndex(modalStack.indexOf(currentModal)) }">
                <div class="modal-content">
                    <div class="modal-header">
                        <button @click="closeModal()" class="close-button" v-if="modalStack.length > 1"><i
                                class="material-icons">arrow_back</i></button>
                        <h2>{{ $t('orderCreated') }}</h2>
                        <button @click="closeModal()" class="close-button">&times;</button>
                    </div>
                    <div class="modal-body">
                        <p>{{ $t('orderId') }}: <strong>{{ orderConfirmation.orderId }}</strong></p>
                        <p>{{ $t('total') }}: <strong>{{ formattedPrice(orderConfirmation.total) }}</strong></p>
                        <p>{{ $t('paymentMethod') }}: <strong>{{ $t(orderConfirmation.paymentMethod) }}</strong></p>
                        <h3>{{ $t('orderDetails') }}:</h3>
                        <ul>
                            <li v-for="item in orderConfirmation.items" :key="item.id">
                                {{ item.name }} x {{ item.quantity }} - {{ formattedPrice(item.price * item.quantity) }}
                            </li>
                        </ul>
                    </div>
                    <div class="modal-footer">
                        <button @click="closeModal()">{{ $t('close') }}</button>
                    </div>
                </div>
            </div>

            <div v-if="currentModal && currentModal.name === 'orderHistory'" class="modal-overlay"
                :style="{ zIndex: getModalZIndex(modalStack.indexOf(currentModal)) }">
                <div class="modal-content">
                    <div class="modal-header">
                        <button @click="closeModal()" class="close-button" v-if="modalStack.length > 1"><i
                                class="material-icons">arrow_back</i></button>
                        <h2>{{ $t('orderHistory') }}</h2>
                        <button @click="closeModal()" class="close-button">&times;</button>
                    </div>
                    <div v-if="orderHistory.length === 0" class="modal-body">
                        <p>{{ $t('noOrderHistory') }}</p>
                    </div>
                    <div v-else class="modal-body">
                        <div v-for="order in orderHistory" :key="order.orderId" class="order-history-card">
                            <h3>{{ $t('orderId') }}: {{ order.orderId }}</h3>
                            <p>{{ $t('date') }}: {{ new Date(order.timestamp).toLocaleString() }}</p>
                            <p>{{ $t('total') }}: {{ formattedPrice(order.total) }}</p>
                            <p>{{ $t('paymentMethod') }}: {{ $t(order.paymentMethod) }}</p>
                            <div class="delivery-status-container">
                                <h4>{{ $t('deliveryStatus') }}</h4>
                                <div class="progress-bar">
                                    <div v-for="(status, index) in deliveryStatuses" :key="index"
                                        :class="getStepClass(order, status)">
                                        <div class="step-dot"></div>
                                        <div class="step-label">{{ $t(status) }}</div>
                                        <span v-if="getDeliveryStatusTimestamp(order, status)" class="status-timestamp"
                                            v-html="getDeliveryStatusTimestamp(order, status)"></span>
                                    </div>
                                </div>
                                <button @click="updateDeliveryStatus(order)" class="update-status-btn">{{
                                    $t('updateStatus') }}</button>
                            </div>
                            <h4>{{ $t('orderDetails') }}:</h4>
                            <ul>
                                <li v-for="item in order.items" :key="item.id">
                                    <span>{{ item.name }} x {{ item.quantity }} - {{ formattedPrice(item.price *
                                        item.quantity) }}</span>
                                    <button v-if="!isReviewed(order.orderId, item.productId)"
                                        @click="openModal('leaveReview', { product: item, orderId: order.orderId })"
                                        class="review-item-btn">{{ $t('leaveReview') }}</button>
                                    <span v-else class="reviewed-tag">{{ $t('itemReviewed') }}</span>
                                </li>
                            </ul>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button @click="closeModal()" class="remove-btn">{{ $t('closeOrderHistory') }}</button>
                    </div>
                </div>
            </div>





            <div v-if="currentModal && currentModal.name === 'editProductDetails'" class="modal-overlay"
                :style="{ zIndex: getModalZIndex(modalStack.indexOf(currentModal)) }">
                <div class="modal-content">
                    <div class="modal-header">
                        <button @click="closeModal()" class="close-button" v-if="modalStack.length > 1"><i
                                class="material-icons">arrow_back</i></button>
                        <h2>{{ $t('editProduct') }}</h2>
                        <button @click="closeModal()" class="close-button">&times;</button>
                    </div>
                    <div class="modal-body">
                        <p>{{ $t('productName') }}: <strong>{{ currentModal.data.product.name }}</strong></p>
                        <div class="form-group">
                            <label for="edit-product-name">{{ $t('productName') }}: </label>
                            <input type="text" id="edit-product-name" v-model="currentModal.data.newProductName"
                                class="form-input form-input-wide">
                        </div>
                        <div class="form-group">
                            <label for="edit-product-price">{{ $t('price') }}: </label>
                            <input type="number" id="edit-product-price"
                                v-model.number="currentModal.data.newProductPrice" min="0" class="form-input">
                        </div>
                        <div class="form-group">
                            <label for="edit-product-stock">{{ $t('stock') }}: </label>
                            <input type="number" id="edit-product-stock"
                                v-model.number="currentModal.data.newProductStock" min="0" class="form-input">
                        </div>
                        <div class="form-group">
                            <label for="edit-product-brand">{{ $t('brand') }}: </label>
                            <input type="text" id="edit-product-brand" v-model="currentModal.data.newProductBrand"
                                class="form-input form-input-wide">
                        </div>
                        <div class="form-group">
                            <label for="edit-product-image">{{ $t('imageUrl') }}: </label>
                            <input type="text" id="edit-product-image" v-model="currentModal.data.newProductImage"
                                class="form-input form-input-wide">
                        </div>
                        <div class="form-group">
                            <label for="stock-change-reason">{{ $t('reason') }}: </label>
                            <input type="text" id="stock-change-reason" v-model="currentModal.data.stockChangeReason"
                                :placeholder="$t('stockChangeReason')" class="form-input form-input-wide">
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button @click="confirmEditProductDetails">{{ $t('saveChanges') }}</button>
                        <button @click="closeModal()" class="remove-btn">{{ $t('cancel') }}</button>
                    </div>
                </div>
            </div>

            <div v-if="currentModal && currentModal.name === 'stockHistory'" class="modal-overlay"
                :style="{ zIndex: getModalZIndex(modalStack.indexOf(currentModal)) }">
                <div class="modal-content">
                    <div class="modal-header">
                        <button @click="closeModal()" class="close-button" v-if="modalStack.length > 1"><i
                                class="material-icons">arrow_back</i></button>
                        <h2>{{ $t('stockHistory') }} <span v-if="currentModal.data.product">- {{
                                currentModal.data.product.name }}</span></h2>
                        <button @click="closeModal()" class="close-button">&times;</button>
                    </div>
                    <div v-if="stockHistory.length === 0" class="modal-body">
                        <p>{{ $t('noStockHistory') }}</p>
                    </div>
                    <div v-else class="modal-body">
                        <div v-for="entry in stockHistory" :key="entry.id" class="stock-history-card">
                            <p><strong>{{ $t('date') }}:</strong> {{ new Date(entry.timestamp).toLocaleString() }}</p>
                            <p><strong>{{ $t('reason') }}:</strong> {{ entry.reason }}</p>
                            <p><strong>{{ $t('stock') }}:</strong> {{ entry.oldStock }} -> {{ entry.newStock }}</p>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button @click="closeModal()" class="remove-btn">{{ $t('close') }}</button>
                    </div>
                </div>
            </div>

            <div v-if="currentModal && currentModal.name === 'productManagement'" class="modal-overlay"
                :style="{ zIndex: getModalZIndex(modalStack.indexOf(currentModal)) }">
                <div class="modal-content">
                    <div class="modal-header">
                        <button @click="closeModal()" class="close-button" v-if="modalStack.length > 1"><i
                                class="material-icons">arrow_back</i></button>
                        <h2>{{ $t('productManagement') }}</h2>
                        <button @click="closeModal()" class="close-button">&times;</button>
                    </div>
                    <div class="modal-body">
                        <div class="add-product-section">
                            <h3>{{ $t('addProduct') }}</h3>
                            <div class="form-group-inline">
                                <input type="text" v-model="newProductName" :placeholder="$t('productName')"
                                    class="form-input">
                                <input type="number" v-model.number="newProductPrice" :placeholder="$t('price')"
                                    class="form-input">
                                <input type="number" v-model.number="newProductStock" :placeholder="$t('stock')"
                                    class="form-input">
                                <input type="text" v-model="newProductBrand" :placeholder="$t('brand')"
                                    class="form-input">
                                <input type="text" v-model="newProductImage" :placeholder="$t('imageUrl')"
                                    class="form-input">
                                <button @click="addNewProduct">{{ $t('addProduct') }}</button>
                                <button @click="generateRandomProduct">隨機生成產品</button>
                            </div>
                        </div>
                        <div class="products-list modal-products-list">
                            <div v-for="product in productsWithSoldQuantity" :key="product.id" class="product-card"
                                :class="{ deleted: product.deleted }" itemscope itemtype="http://schema.org/Product">
                                <div class="product-header">
                                    <h3 itemprop="name">{{ product.name }}</h3>
                                    <div class="product-actions dropdown">
                                        <button class="icon-button dropbtn">
                                            <i class="material-icons">more_vert</i>
                                        </button>
                                        <div class="dropdown-content">
                                            <a href="#"
                                                @click.prevent="openModal('editProductDetails', { product: product, newProductName: product.name, newProductPrice: product.price, newProductStock: product.stock, newProductBrand: product.brand, newProductImage: product.images.join(','), stockChangeReason: '', stockChanged: false })"><i
                                                    class="material-icons">edit</i> {{ $t('editProduct') }}</a>
                                            <a href="#" @click.prevent="viewStockHistory(product)"><i
                                                    class="material-icons">history</i> {{ $t('viewHistory') }}</a>
                                            <a v-if="!product.deleted" href="#"
                                                @click.prevent="deleteProduct(product)"><i
                                                    class="material-icons">delete</i> {{ $t('deleteProduct') }}</a>
                                            <a v-if="product.deleted" href="#"
                                                @click.prevent="restoreProduct(product)"><i
                                                    class="material-icons">restore</i> {{ $t('restore') }}</a>
                                        </div>
                                    </div>
                                </div>
                                <img itemprop="image" :src="product.image || 'https://via.placeholder.com/150'"
                                    alt="Product Image" style="display: none;">
                                <div itemprop="offers" itemscope itemtype="http://schema.org/Offer">
                                    <p>{{ $t('price') }}: <span itemprop="price">{{ formattedPrice(product.price)
                                            }}</span></p>
                                    <meta itemprop="priceCurrency" content="TWD" />
                                </div>
                                <p>{{ $t('stock') }}: <span itemprop="inventoryLevel">{{ product.stock }}</span></p>
                                <div itemprop="brand" itemscope itemtype="http://schema.org/Brand"
                                    style="display: none;">
                                    <span itemprop="name">{{ product.brand || 'N/A' }}</span>
                                </div>
                                <div itemprop="aggregateRating" itemscope itemtype="http://schema.org/AggregateRating"
                                    style="display: none;">
                                    <span itemprop="ratingValue">{{ product.rating || 'N/A' }}</span>
                                    <span itemprop="reviewCount">0</span>
                                </div>
                                <p>{{ $t('sold') }}: {{ product.soldQuantity }}</p>
                            </div>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button @click="closeModal()" class="remove-btn">{{ $t('closeProductManagement') }}</button>
                    </div>
                </div>
            </div>

            <div v-if="currentModal && currentModal.name === 'carouselManagement'" class="modal-overlay"
                :style="{ zIndex: getModalZIndex(modalStack.indexOf(currentModal)) }">
                <div class="modal-content">
                    <div class="modal-header">
                        <button @click="closeModal()" class="close-button" v-if="modalStack.length > 1"><i
                                class="material-icons">arrow_back</i></button>
                        <h2>{{ $t('manageCarousel') }}</h2>
                        <button @click="closeModal()" class="close-button">&times;</button>
                    </div>
                    <div class="modal-body">
                        <div class="add-image-section">
                            <h3>{{ $t('addImage') }}</h3>
                            <div class="form-group-inline">
                                <input type="text" v-model="newImageUrl" :placeholder="$t('imageUrl')"
                                    class="form-input form-input-wide">
                                <button @click="addCarouselImage">{{ $t('addImage') }}</button>
                            </div>
                        </div>
                        <div class="images-list">
                            <div v-for="(image, index) in carouselImages" :key="index" class="image-card">
                                <img :src="image.url" class="image-card-preview">
                                <button @click="removeCarouselImage(image)" class="remove-btn"><i
                                        class="material-icons">delete</i></button>
                            </div>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button @click="closeModal()" class="remove-btn">{{ $t('close') }}</button>
                    </div>
                </div>
            </div>

            <!-- Product Reviews Modal -->
            <div v-if="currentModal && currentModal.name === 'productReviews'" class="modal-overlay"
                :style="{ zIndex: getModalZIndex(modalStack.indexOf(currentModal)) }">
                <div class="modal-content">
                    <div class="modal-header">
                        <button @click="closeModal()" class="close-button" v-if="modalStack.length > 1"><i
                                class="material-icons">arrow_back</i></button>
                        <h2>{{ $t('reviews') }} - {{ currentModal.data.product.name }}</h2>
                        <button @click="closeModal()" class="close-button">&times;</button>
                    </div>
                    <div class="modal-body">
                        <!-- Average Rating -->
                        <div class="average-rating-section">
                            <h3>{{ $t('averageRating') }}</h3>
                            <div class="star-rating-display">
                                <i v-for="(star, index) in getDisplayStars(getAverageRating(reviewProductId))"
                                    :key="index" class="material-icons" :style="{ color: star.color }">{{ star.icon
                                    }}</i>
                            </div>
                            <p>{{ getAverageRating(reviewProductId).toFixed(1) }} / 5.0 ({{
                                getProductReviews(reviewProductId).length }} {{ $t('reviewCountText') }})</p>
                        </div>

                        <!-- Existing Reviews -->
                        <div class="reviews-list">
                            <div v-if="getProductReviews(reviewProductId).length === 0">
                                <p>{{ $t('noReviewsYet') }}</p>
                            </div>
                            <div v-else v-for="review in getProductReviews(reviewProductId)" :key="review.id"
                                class="review-card">
                                <div class="review-header">
                                    <div class="star-rating-display">
                                        <i v-for="(star, index) in getDisplayStars(review.rating)" :key="index"
                                            class="material-icons" :style="{ color: star.color }">{{ star.icon }}</i>
                                    </div>
                                    <span class="review-timestamp">{{ new Date(review.timestamp).toLocaleString()
                                        }}</span>
                                </div>
                                <p class="review-comment">{{ review.comment }}</p>
                            </div>
                        </div>

                        <!-- Leave a Review Form is now in its own modal -->
                    </div>
                </div>
            </div>

            <!-- Leave Review Modal -->
            <div v-if="currentModal && currentModal.name === 'leaveReview'" class="modal-overlay"
                :style="{ zIndex: getModalZIndex(modalStack.indexOf(currentModal)) }">
                <div class="modal-content">
                    <div class="modal-header">
                        <button @click="closeModal()" class="close-button" v-if="modalStack.length > 1"><i
                                class="material-icons">arrow_back</i></button>
                        <h2>{{ $t('leaveReview') }} - {{ currentModal.data.product.name }}</h2>
                        <button @click="closeModal()" class="close-button">&times;</button>
                    </div>
                    <div class="modal-body">
                        <div class="review-form">
                            <div class="form-group">
                                <label>{{ $t('yourRating') }}:</label>
                                <div class="star-rating-input-interactive" @mouseleave="resetHoverRating">
                                    <i v-for="n in 5" :key="n" class="material-icons"
                                        @mousemove="updateHoverRating(n, $event)" @click="setRating">
                                        {{ getStarDisplayClass(n) }}
                                    </i>
                                </div>
                            </div>
                            <div class="form-group">
                                <label for="review-comment">{{ $t('yourComment') }}:</label>
                                <textarea id="review-comment" v-model="newReview.comment"
                                    class="form-input form-input-wide"></textarea>
                            </div>
                            <button
                                @click="submitReview(currentModal.data.product.productId, currentModal.data.orderId)"
                                class="submit-review-btn">{{ $t('submitReview') }}</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Custom Alert/Confirm Modal -->
            <div v-if="notification.show" class="modal-overlay" style="z-index: 9999;">
                <div class="modal-content">
                    <div class="modal-header">
                        <h2>{{ notification.title }}</h2>
                    </div>
                    <div class="modal-body">
                        <p>{{ notification.message }}</p>
                    </div>
                    <div class="modal-footer">
                        <button v-if="notification.type === 'confirm'" @click="handleConfirmation(true)">{{
                            $t('confirm')
                            }}</button>
                        <button @click="handleConfirmation(false)"
                            :class="{ 'remove-btn': notification.type === 'confirm' }">{{
                            notification.type === 'confirm' ? $t('cancel') : $t('close') }}</button>
                    </div>
                </div>
            </div>
    </div>

    <script src="https://unpkg.com/swiper/swiper-bundle.min.js"></script>
    <!-- Vue 3 CDN -->
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <!-- Dexie.js (for IndexedDB) CDN -->
    <script src="https://unpkg.com/dexie@3/dist/dexie.js"></script>
    <!-- Vue I18n CDN -->
    <script src="https://unpkg.com/vue-i18n@9/dist/vue-i18n.global.js"></script>
    <!-- I18n Messages -->
    <script src="i18n.js"></script>
    <script src="header-component.js"></script>
    <script src="db.js"></script>

    <script>
        const { createApp, reactive } = Vue;
        const { createI18n } = VueI18n;

        const i18n = createI18n({
            locale: 'zh-TW', // 預設語言
            fallbackLocale: 'en-US',
            messages,
        });

        const app = createApp({
            data() {
                return {
                    products: [],
                    cart: [], // 購物車內容
                    newProductName: '',
                    newProductPrice: null,
                    newProductStock: 0,
                    newProductBrand: '',
                    newProductImage: '',
                    productSwipers: {},
                    paymentMethod: 'credit_card', // 預設支付方式
                    orderConfirmation: null, // 儲存訂單確認資訊
                    orderHistory: [], // 儲存歷史訂單
                    deliveryStatuses: ['Order Placed', 'Payment Confirmed', 'Order Shipped', 'Order Complete', 'Pending Review'],
                    isLoading: true, // 控制初始載入畫面
                    isProcessingOrder: false, // 控制結帳處理載入畫面
                    isAddingToEmptyCart: false, // 控制加入空購物車時的載入畫面
                    locale: 'zh-TW', // 預設語言為繁體中文
                    stockHistory: [],
                    carouselImages: [],
                    newImageUrl: '',
                    modalStack: [], // Centralized modal management
                    reviews: [], // To store all product reviews
                    newReview: {
                        rating: 0,
                        comment: ''
                    },
                    hoverRating: 0,
                    notification: {
                        show: false,
                        type: 'alert', // 'alert' or 'confirm'
                        title: '',
                        message: '',
                        onConfirm: null
                    },
                    isSmallScreen: false, // New reactive property
                };
            },
            computed: {
                getCarouselImages() {
                    return this.carouselImages;
                },
                cartTotal() {
                    return this.cart.reduce((total, item) => total + (item.price * item.quantity), 0);
                },
                totalQuantity() {
                    return this.cart.reduce((total, item) => total + item.quantity, 0);
                },
                productsWithSoldQuantity() {
                    const soldQuantities = {};
                    this.orderHistory.forEach(order => {
                        order.items.forEach(item => {
                            soldQuantities[item.productId] = (soldQuantities[item.productId] || 0) + item.quantity;
                        });
                    });

                    return this.products.map(product => ({
                        ...product,
                        soldQuantity: soldQuantities[product.id] || 0
                    }));
                },
                filteredProducts() {
                    return this.productsWithSoldQuantity.filter(p => !p.deleted);
                },
                currentModal() {
                    return this.modalStack.length > 0 ? this.modalStack[this.modalStack.length - 1] : null;
                },
                showModalOverlay() {
                    return this.modalStack.length > 0;
                },
                reviewProductId() {
                    if (this.currentModal && this.currentModal.name === 'productReviews') {
                        const product = this.currentModal.data.product;
                        return product.productId || product.id;
                    }
                    return null;
                }
            },
            watch: {
                showModalOverlay(newValue) {
                    if (newValue) {
                        document.body.classList.add('modal-open');
                    } else {
                        document.body.classList.remove('modal-open');
                    }
                },
                'notification.show': function (newValue) {
                    if (newValue) {
                        document.body.classList.add('modal-open');
                    } else if (!this.showModalOverlay) { // Only remove if no other modals are open
                        document.body.classList.remove('modal-open');
                    }
                }
            },
            methods: {
                getYouTubeEmbedUrl(url) {
                    const youtubeRegex = /(?:https?:\/\/)?(?:www\.)?(?:youtube\.com\/watch\?v=|youtu\.be\/)([\w-]+)/;
                    const match = url.match(youtubeRegex);
                    if (match && match[1]) {
                        return `https://www.youtube.com/embed/${match[1]}`;
                    }
                    return url; // Fallback
                },

                getMediaType(url) {
                    if (url.includes('youtube.com') || url.includes('youtu.be')) {
                        return 'youtube';
                    }
                    const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.bmp', '.webp', '.svg'];
                    const videoExtensions = ['.mp4', '.webm', '.ogg'];
                    const lowercasedUrl = url.toLowerCase();
                    if (imageExtensions.some(ext => lowercasedUrl.endsWith(ext))) {
                        return 'image';
                    }
                    if (videoExtensions.some(ext => lowercasedUrl.endsWith(ext))) {
                        return 'video';
                    }
                    return 'image'; // Default to image if no match
                },

                toggleMute(event) {
                    const button = event.target;
                    const video = button.previousElementSibling;
                    video.muted = !video.muted;
                    button.textContent = video.muted ? 'volume_off' : 'volume_up';
                },

                isImage(url) {
                    const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.bmp', '.webp', '.svg'];
                    const lowercasedUrl = url.toLowerCase();
                    return imageExtensions.some(ext => lowercasedUrl.endsWith(ext));
                },
                getProductReviews(productId) {
                    return this.reviews.filter(r => r.productId === productId).sort((a, b) => b.timestamp - a.timestamp);
                },
                getAverageRating(productId) {
                    const productReviews = this.getProductReviews(productId);
                    if (productReviews.length === 0) return 0;
                    const totalRating = productReviews.reduce((sum, review) => sum + review.rating, 0);
                    return totalRating / productReviews.length;
                },
                getDisplayStars(rating) {
                    const stars = [];
                    for (let i = 1; i <= 5; i++) {
                        if (rating >= i) {
                            stars.push({ icon: 'star', color: '#f5c518' });
                        } else if (rating >= i - 0.5) {
                            stars.push({ icon: 'star_half', color: '#f5c518' });
                        } else {
                            stars.push({ icon: 'star_border', color: '#ccc' });
                        }
                    }
                    return stars;
                },
                isReviewed(orderId, productId) {
                    return this.reviews.some(review => review.orderId === orderId && review.productId === productId);
                },
                updateHoverRating(starIndex, event) {
                    const rect = event.target.getBoundingClientRect();
                    const mouseX = event.clientX - rect.left;
                    this.hoverRating = starIndex - (mouseX < rect.width / 2 ? 0.5 : 0);
                },
                setRating() {
                    this.newReview.rating = this.hoverRating;
                },
                resetHoverRating() {
                    this.hoverRating = 0;
                },
                getStarDisplayClass(starIndex) {
                    const displayRating = this.hoverRating || this.newReview.rating;
                    if (displayRating >= starIndex) {
                        return 'star';
                    } else if (displayRating >= starIndex - 0.5) {
                        return 'star_half';
                    } else {
                        return 'star_border';
                    }
                },
                checkScreenSize() {
                    this.isSmallScreen = window.innerWidth <= 768; // Define your breakpoint for small screens
                },
                openModal(name, data = {}) {
                    this.modalStack.push({ name, data });
                },
                closeModal() {
                    this.modalStack.pop();
                },
                closeAllModals() {
                    this.modalStack = [];
                },
                getModalZIndex(index) {
                    return 1200 + index;
                },
                showAlert(message, title = 'Info') {
                    this.notification.type = 'alert';
                    this.notification.title = title;
                    this.notification.message = message;
                    this.notification.show = true;
                },
                showConfirm(message, title = 'Confirm') {
                    return new Promise((resolve) => {
                        this.notification.type = 'confirm';
                        this.notification.title = title;
                        this.notification.message = message;
                        this.notification.show = true;
                        this.notification.onConfirm = resolve;
                    });
                },
                handleConfirmation(isConfirmed) {
                    if (this.notification.onConfirm) {
                        this.notification.onConfirm(isConfirmed);
                    }
                    this.notification.show = false;
                    this.notification.onConfirm = null; // Reset for next time
                },
                generateUUID() {
                    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
                        var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
                        return v.toString(16);
                    });
                },
                formattedPrice(price) {
                    const locale = this.locale;
                    // Access messages from i18n.global directly, as it's now reactive
                    const localeConfig = i18n.global.messages[locale];

                    if (localeConfig && localeConfig.currencyFormat) {
                        const convertedPrice = price * (localeConfig.exchangeRate || 1);
                        const finalPrice = Number.isInteger(convertedPrice) ? convertedPrice : convertedPrice.toFixed(2);
                        return localeConfig.currencyFormat
                            .replace('{symbol}', localeConfig.currencySymbol || '')
                            .replace('{value}', finalPrice);
                    }
                    return `NT${price}`;
                },
                async loadProducts() {
                    try {
                        this.products = await databaseService.getAll('products');
                        this.initProductSwipers();
                    } catch (error) {
                        console.error("Could not load products from IndexedDB:", error);
                    }
                },
                async loadCart() {
                    try {
                        this.cart = await databaseService.getAll('cart');
                    } catch (error) {
                        console.error("Could not load cart from IndexedDB:", error);
                    }
                },
                async addToCart(product) {
                    if (product.stock === 0) {
                        this.showAlert(this.$t('productSoldOut'));
                        return;
                    }

                    const wasCartEmpty = this.cart.length === 0;
                    if (wasCartEmpty) {
                        this.isAddingToEmptyCart = true;
                    }

                    try {
                        await databaseService.addToCart(product);
                        await this.loadCart();

                        if (wasCartEmpty) {
                            await new Promise(resolve => setTimeout(resolve, 600));
                            this.isAddingToEmptyCart = false;
                        }

                    } catch (error) {
                        if (wasCartEmpty) {
                            this.isAddingToEmptyCart = false;
                        }
                        if (error.message === 'maxQuantityReached') {
                            this.showAlert(this.$t('maxQuantityReached'));
                        } else {
                            console.error("Error adding to cart:", error);
                        }
                    }
                },
                async removeFromCart(itemId) {
                    try {
                        await databaseService.deleteItem('cart', itemId);
                        await this.loadCart();
                    } catch (error) {
                        console.error("Error removing from cart:", error);
                    }
                },
                async updateQuantity(item, change) {
                    try {
                        const productInStock = this.products.find(p => p.id === item.productId);
                        
                        if (change > 0 && productInStock && (item.quantity + change) > productInStock.stock) {
                            this.showAlert(this.$t('maxQuantityReached'));
                            return;
                        }

                        if ((item.quantity + change) === 0) {
                            const confirmed = await this.showConfirm(this.$t('confirmRemoveProduct', { productName: item.name }));
                            if (!confirmed) {
                                return; // User canceled the removal
                            }
                        }
                        
                        await databaseService.updateCartQuantity(item, change, productInStock ? productInStock.stock : 0);
                        await this.loadCart();
                    } catch (error) {
                         if (error.message === 'maxQuantityReached') {
                            this.showAlert(this.$t('maxQuantityReached'));
                        } else {
                            console.error("Error updating quantity:", error);
                        }
                    }
                },
                async addNewProduct() {
                    if (this.newProductName && this.newProductPrice > 0) {
                        const newProduct = {
                            id: this.generateUUID(),
                            name: this.newProductName,
                            price: parseFloat(this.newProductPrice),
                            stock: this.newProductStock,
                            brand: this.newProductBrand || 'N/A',
                            rating: 'N/A',
                            images: this.newProductImage ? this.newProductImage.split(',').map(s => s.trim()) : [],
                            deleted: false
                        };
                        await databaseService.addItem('products', newProduct);
                        await this.loadProducts();
                        this.newProductName = '';
                        this.newProductPrice = null;
                        this.newProductStock = 0;
                        this.newProductBrand = '';
                        this.newProductImage = '';
                    } else {
                        alert(this.$t('enterValidProduct'));
                    }
                },
                async generateRandomProduct() {
                    const randomNames = ['T恤', '牛仔褲', '運動鞋', '帽子', '背包', '手錶', '太陽眼鏡', '耳機', '鍵盤', '滑鼠'];
                    const randomName = randomNames[Math.floor(Math.random() * randomNames.length)] + '-' + Math.floor(Math.random() * 1000);
                    const randomPrice = parseFloat((Math.random() * 100 + 10).toFixed(2));
                    const randomStock = Math.floor(Math.random() * 100) + 1;
                    const randomBrand = ['Nike', 'Adidas', 'Puma', 'Sony', 'Apple'][Math.floor(Math.random() * 5)];
                    const randomRating = (Math.random() * 5).toFixed(1);

                    const newProduct = {
                        id: this.generateUUID(),
                        name: randomName,
                        price: randomPrice,
                        stock: randomStock,
                        brand: randomBrand,
                        rating: randomRating,
                        images: [],
                        deleted: false
                    };
                    await databaseService.addItem('products', newProduct);
                    await this.loadProducts();
                },
                async seedInitialData() {
                    try {
                        const response = await fetch('shoppingcart_backup.json');
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        const data = await response.json();
                        
                        const mappedData = {
                             products: data.products ? data.products.map(p => ({
                                id: p.id || this.generateUUID(),
                                name: p.name,
                                price: p.price,
                                stock: p.stock,
                                brand: p.brand,
                                rating: p.rating,
                                images: p.images || [],
                                deleted: p.deleted || false
                            })) : [],
                            carouselImages: data.carouselImages || []
                        };

                        await databaseService.seedData(mappedData);
                        console.log("Database seeded successfully.");
                    } catch (error) {
                        console.error("Failed to seed initial data from JSON:", error);
                    }
                },
                async deleteProduct(product) {
                    if (confirm(this.$t('deleteConfirmation', { productName: product.name }))) {
                        try {
                            await databaseService.deleteProduct(product.id);
                            await this.loadProducts();
                            await this.loadCart();
                        } catch (error) {
                            console.error("Error deleting product:", error);
                            alert("Failed to delete product.");
                        }
                    }
                },
                async restoreProduct(product) {
                    try {
                        await databaseService.updateItem('products', product.id, { deleted: false });
                        await this.loadProducts();
                    } catch (error) {
                        console.error("Error restoring product:", error);
                        alert("Failed to restore product.");
                    }
                },
                async clearCart() {
                    try {
                        await databaseService.clearStore('cart');
                        await this.loadCart();
                    } catch (error) {
                        console.error("Error clearing cart:", error);
                    }
                },
                startCheckout() {
                    this.openModal('checkout');
                },
                async processCheckout() {
                    if (this.cart.length === 0) {
                        alert(this.$t('cartEmptyCheckout'));
                        return;
                    }

                    if (!this.paymentMethod) {
                        alert(this.$t('selectPaymentMethod'));
                        return;
                    }

                    for (const cartItem of this.cart) {
                        const product = this.products.find(p => p.id === cartItem.productId);
                        if (!product || product.stock < cartItem.quantity) {
                            alert(this.$t('insufficientStock', { productName: cartItem.name, stock: product ? product.stock : 0, quantity: cartItem.quantity }));
                            return;
                        }
                    }

                    try {
                        this.isProcessingOrder = true;

                        const orderId = `ORD-${Date.now()}-${Math.floor(Math.random() * 1000)}`;
                        const order = {
                            orderId: orderId,
                            total: this.cartTotal,
                            paymentMethod: this.paymentMethod,
                            timestamp: new Date().toISOString(),
                            items: this.cart.map(item => ({ ...item })),
                            deliveryStatus: 'Order Placed',
                            deliveryHistory: [{ status: 'Order Placed', timestamp: new Date().toISOString() }]
                        };

                        await databaseService.processCheckout(order, this.cart);

                        await this.loadProducts();
                        await this.loadCart();
                        await this.loadOrderHistory();

                        await new Promise(resolve => setTimeout(resolve, 1000));

                        this.isProcessingOrder = false;
                        this.orderConfirmation = order;
                        this.closeModal();
                        this.openModal('orderConfirmation', order);
                        this.showAlert(this.$t('checkoutSuccess'));

                    } catch (error) {
                        this.isProcessingOrder = false;
                        console.error("Error processing checkout:", error);
                        alert(this.$t('checkoutFailed'));
                    }
                },
                async toggleOrderHistory() {
                    await this.loadOrderHistory();
                    this.openModal('orderHistory');
                },
                async loadOrderHistory() {
                    try {
                        let orders = await databaseService.getAll('orders');
                        orders = orders.map(order => {
                            if (!order.deliveryHistory) {
                                order.deliveryHistory = [{
                                    status: order.deliveryStatus || 'Order Placed',
                                    timestamp: order.timestamp || new Date().toISOString()
                                }];
                            }
                            return order;
                        });
                        this.orderHistory = orders.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
                    } catch (error) {
                        console.error("Could not load order history from IndexedDB:", error);
                    }
                },

                getStepClass(order, status) {
                    const currentIndex = this.deliveryStatuses.indexOf(order.deliveryStatus);
                    const stepIndex = this.deliveryStatuses.indexOf(status);
                    const isFinalState = order.deliveryStatus === 'Pending Review';
                    
                    // Check if all items in the order have been reviewed.
                    const allItemsReviewed = order.items.every(item => this.isReviewed(order.orderId, item.productId));

                    return {
                        'step': true,
                        // A step is completed if it's a past step, OR if the current step is the final one AND all items are reviewed.
                        'completed': stepIndex < currentIndex || (stepIndex === currentIndex && isFinalState && allItemsReviewed),
                        // A step is active if it's the current step, BUT NOT if it's the final state and all items are reviewed (because then it's completed).
                        'active': stepIndex === currentIndex && !(isFinalState && allItemsReviewed),
                    };
                },

                getDeliveryStatusTimestamp(order, status) {
                    const historyEntry = order.deliveryHistory.find(entry => entry.status === status);
                    if (historyEntry) {
                        const date = new Date(historyEntry.timestamp);
                        const datePart = date.toLocaleDateString(this.locale);
                        const timePart24hr = date.toLocaleTimeString(this.locale, { hour: '2-digit', minute: '2-digit', hourCycle: 'h23' });

                        if (this.isSmallScreen) {
                            return `${datePart} ${timePart24hr}`;
                        } else {
                            return `${datePart}<br>${timePart24hr}`;
                        }
                    }
                    return '';
                },

                async updateDeliveryStatus(order) {
                    const currentIndex = this.deliveryStatuses.indexOf(order.deliveryStatus);
                    if (currentIndex >= this.deliveryStatuses.length - 1) return; // Already at the end

                    const nextStatus = this.deliveryStatuses[currentIndex + 1];

                    // ONLY check for reviews when moving from 'Order Complete' to the final 'Pending Review' state.
                    if (order.deliveryStatus === 'Order Complete' && nextStatus === 'Pending Review') {
                        const allReviewed = order.items.every(item => this.isReviewed(order.orderId, item.productId));
                        // if (!allReviewed) {
                        //     this.showAlert(this.$t('cannotUpdateUnreviewedOrder'));
                        //     return;
                        // }
                    }

                    try {
                        const orderToUpdate = await databaseService.getItem('orders', order.id);
                        if (orderToUpdate) {
                            const newHistory = [...(orderToUpdate.deliveryHistory || []), { status: nextStatus, timestamp: new Date().toISOString() }];
                            await databaseService.updateItem('orders', order.id, {
                                deliveryStatus: nextStatus,
                                deliveryHistory: newHistory
                            });
                            await this.loadOrderHistory();
                        }
                    } catch (error) {
                        console.error("Error updating delivery status:", error);
                        this.showAlert('Failed to update status.');
                    }
                },
                startEditStock(product) {
                    this.openModal('editStock', { product: { ...product }, newStock: product.stock, stockChangeReason: '' });
                },
                async confirmEditProductDetails() {
                    const product = this.currentModal.data.product;
                    const details = {
                        name: this.currentModal.data.newProductName,
                        price: parseFloat(this.currentModal.data.newProductPrice),
                        stock: parseInt(this.currentModal.data.newProductStock),
                        brand: this.currentModal.data.newProductBrand,
                        images: this.currentModal.data.newProductImage ? this.currentModal.data.newProductImage.split(',').map(s => s.trim()) : [],
                        stockChangeReason: this.currentModal.data.stockChangeReason,
                        stockChanged: parseInt(this.currentModal.data.newProductStock) !== product.stock
                    };

                    if (!details.name || isNaN(details.price) || details.price <= 0 || isNaN(details.stock) || details.stock < 0) {
                        this.showAlert(this.$t('enterValidProduct'));
                        return;
                    }

                    if (details.stockChanged && !details.stockChangeReason) {
                        this.showAlert(this.$t('reasonRequired'));
                        return;
                    }

                    try {
                        await databaseService.updateProductDetails(product, details);
                        await this.loadProducts();
                        await this.loadCart();
                        this.closeModal();
                    } catch (error) {
                        console.error("Error confirming product details edit:", error);
                        this.showAlert(`${this.$t('checkoutFailed')} ${error.message || error}`);
                    }
                },
                cancelEditStock() {
                    this.closeModal();
                },
                async viewStockHistory(product) {
                    this.stockHistory = [];
                    try {
                        const history = await databaseService.getItemWhere('stockHistory', {productId: product.id}).toArray();
                        this.stockHistory = history.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
                        this.openModal('stockHistory', { product: product });
                    } catch (error) {
                        console.error("Could not load stock history from IndexedDB:", error);
                        this.showAlert("Failed to load stock history.");
                    }
                },
                async loadCarouselImages() {
                    try {
                        this.carouselImages = await databaseService.getAll('carouselImages');
                        this.initSwiper();
                    } catch (error) {
                        console.error("Could not load carousel images from IndexedDB:", error);
                    }
                },
                initSwiper() {
                    this.$nextTick(() => {
                        if (this.swiper) {
                            this.swiper.destroy(true, true);
                        }

                        const swiperOptions = {
                            observer: true,
                            observeParents: true,
                            pagination: {
                                el: '.swiper-pagination',
                                clickable: true,
                            },
                            navigation: {
                                nextEl: '.swiper-button-next',
                                prevEl: '.swiper-button-prev',
                            },
                            autoplay: {
                                delay: 3000,
                                disableOnInteraction: false,
                            },
                        };

                        if (this.carouselImages.length >= 3) {
                            swiperOptions.loop = true;
                        }

                        this.swiper = new Swiper('.main-carousel', swiperOptions);
                    });
                },
                initProductSwipers() {
                    this.$nextTick(() => {
                        this.products.forEach(product => {
                            const swiperSelector = `.product-swiper-${product.id}`;
                            if (this.productSwipers[product.id]) {
                                this.productSwipers[product.id].destroy(true, true);
                            }
                            this.productSwipers[product.id] = new Swiper(swiperSelector, {
                                observer: true,
                                observeParents: true,
                                pagination: {
                                    el: `.product-pagination-${product.id}`,
                                    clickable: true,
                                },
                            });
                        });
                    });
                },
                async addCarouselImage() {
                    if (!this.newImageUrl) return;

                    const existing = this.carouselImages.some(img => img.url === this.newImageUrl);
                    if (existing) {
                        alert(this.$t('imageExists'));
                        return;
                    }
                    
                    const newImage = { url: this.newImageUrl };
                    try {
                        await databaseService.addItem('carouselImages', newImage);
                        this.newImageUrl = '';
                        await this.loadCarouselImages();
                    } catch (error) {
                        console.error("Error adding carousel image to DB:", error);
                        alert(this.$t('dbErrorReverted'));
                    }
                },

                async removeCarouselImage(image) {
                    try {
                        await databaseService.deleteItem('carouselImages', image.id);
                        await this.loadCarouselImages();
                    } catch (error) {
                        console.error("Error removing carousel image from DB:", error);
                        alert('Failed to remove image.');
                    }
                },
                async fetchExchangeRates() {
                    const BASE_CURRENCY = 'TWD';
                    const API_URL = `https://h-web-api-a2gvavdbg9dggxa3.canadacentral-01.azurewebsites.net/api/Toolbox/ProxyAPI?Url=https%3A%2F%2Fv6.exchangerate-api.com%2Fv6%2Fa80efb83a09fb6489e1e5034%2Flatest%2F${BASE_CURRENCY}`;

                    try {
                        const response = await fetch(API_URL);
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        const data = await response.json();
                        const dataParse = JSON.parse(data.data);
                        const messages = i18n.global.messages;

                        if (dataParse) {
                            for (const localeKey in messages) {
                                if (messages[localeKey].currencySymbol) {
                                    const targetCurrency = messages[localeKey].currencySymbol.replace(/[^a-zA-Z]/g, '');
                                    if (dataParse.conversion_rates[targetCurrency]) {
                                        messages[localeKey].exchangeRate = dataParse.conversion_rates[targetCurrency];
                                    } else {
                                        console.warn(`Exchange rate for ${targetCurrency} not found in API response.`);
                                        messages[localeKey].exchangeRate = 1;
                                    }
                                }
                            }
                            console.log("Exchange rates updated successfully!");
                        } else {
                            console.error("API response does not contain conversion_rates.", data);
                        }
                    } catch (error) {
                        console.error("Failed to fetch exchange rates:", error);
                    }
                },

                async loadReviews() {
                    try {
                        this.reviews = await databaseService.getAll('reviews');
                    } catch (error) {
                        console.error("Could not load reviews from IndexedDB:", error);
                    }
                },

                async submitReview(productId, orderId) {
                    if (this.newReview.rating === 0) {
                        this.showAlert(this.$t('ratingIsRequired'));
                        return;
                    }

                    const review = {
                        orderId: orderId,
                        productId: productId,
                        rating: this.newReview.rating,
                        comment: this.newReview.comment,
                        timestamp: new Date().getTime(),
                    };

                    try {
                        await databaseService.addItem('reviews', review);
                        await this.loadReviews();
                        this.newReview.rating = 0;
                        this.newReview.comment = '';
                        this.closeModal();
                        this.showAlert(this.$t('reviewSubmitted'));
                        await this.checkAndCompleteOrder(orderId);
                    } catch (error) {
                        console.error("Error submitting review:", error);
                        this.showAlert('Failed to submit review.');
                    }
                },

                async checkAndCompleteOrder(orderId) {
                    try {
                        const order = await databaseService.getItemWhere('orders', { orderId: orderId }).first();
                        if (!order || order.deliveryStatus !== 'Order Complete') {
                            // Only proceed if the order exists and is in the 'Order Complete' state.
                            return;
                        }

                        const allReviewed = order.items.every(item =>
                            this.isReviewed(order.orderId, item.productId)
                        );

                        if (allReviewed) {
                            const latestReviewTimestamp = new Date().getTime(); // Use current time for the final step
                            const newHistory = [...(order.deliveryHistory || []), { status: 'Pending Review', timestamp: new Date(latestReviewTimestamp).toISOString() }];
                            
                            await databaseService.updateItem('orders', order.id, {
                                deliveryStatus: 'Pending Review',
                                deliveryHistory: newHistory
                            });

                            await this.loadOrderHistory();
                            // this.showAlert(this.$t('orderCompletedAutomatically', { orderId: order.orderId }));
                        }
                    } catch (error) {
                        console.error("Error checking and completing order:", error);
                    }
                },
            },
            async created() {
                try {
                    await databaseService.init();
                    const productCount = await databaseService.db.products.count();
                    if (productCount === 0) {
                        console.log("Database is empty, seeding initial data...");
                        await this.seedInitialData();
                    }

                    await Promise.all([
                        this.loadProducts(),
                        this.loadCart(),
                        this.loadOrderHistory(),
                        this.loadCarouselImages(),
                        this.loadReviews(),
                        this.fetchExchangeRates()
                    ]);
                } catch (error) {
                    console.error("Failed to initialize the application:", error);
                    this.showAlert('Failed to load database. Please try refreshing.', 'Initialization Error');
                } finally {
                    this.isLoading = false;
                }
                window.addEventListener('resize', this.checkScreenSize);
                this.checkScreenSize(); // Initial check
            },
            beforeUnmount() {
                window.removeEventListener('resize', this.checkScreenSize);
            }
        });

        app.use(i18n);
        app.component('header-component', headerComponent);
        app.mount('#app');
    </script>

    <footer>
        <div class="footer-content">
            <h3>公司資訊</h3>
            <p>公司名稱：Gemini CLI 商店</p>
            <p>地址：模擬地址，模擬城市，模擬國家</p>
            <p>電話：(02) 1234-5678</p>
            <p>電子郵件：info@geminicli.com</p>
        </div>
        <div class="footer-content">
            <h3>更新資訊</h3>
            <p>最後更新日期：2025年7月4日</p>
            <p>版本：1.0.0</p>
        </div>
        <div class="footer-content">
            <details>
                <summary>無障礙標籤與聲明</summary>
                <p>本網站致力於提供無障礙的瀏覽體驗。我們遵循無障礙網頁內容指南 (WCAG) 2.1 AA 級標準。</p>
                <p>如果您在使用本網站時遇到任何無障礙問題，請聯繫我們。</p>
                <ul>
                    <li>鍵盤導航支援</li>
                    <li>高對比模式支援</li>
                    <li>螢幕閱讀器優化</li>
                </ul>
            </details>
        </div>
        <div class="footer-bottom">
            <p>&copy; 2025 Gemini CLI 商店. All rights reserved.</p>
        </div>
    </footer>
</body>

</html>