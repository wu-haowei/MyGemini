<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vue Shopping Cart with IndexedDB</title>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <link rel="stylesheet" href="https://unpkg.com/swiper/swiper-bundle.min.css" />
    <link rel="stylesheet" href="styles.css">
</head>

<body>

    <div id="app">
        <header class="app-header-fixed">
            <div class="app-header-content">
                <h1>{{ $t('shopName') }}</h1>
                <div class="language-selector">
                    <label for="language-select">{{ $t('language') }}: </label>
                    <select id="language-select" v-model="locale" @change="$i18n.locale = locale">
                        <option value="zh-TW">繁體中文</option>
                        <option value="zh-CN">简体中文</option>
                        <option value="ja">日本語</option>
                        <option value="ko">한국어</option>
                        <option value="en-US">English (US)</option>
                        <option value="en-GB">English (UK)</option>
                    </select>
                </div>
            </div>
        </header>

        <main class="main-content">
            <div v-if="isLoading || isProcessingOrder" class="loading-overlay">
                <div class="spinner"></div>
            </div>

            <!-- Carousel -->
            <div class="swiper-container main-carousel">
                <div class="swiper-wrapper">
                    <div class="swiper-slide" v-for="(image, index) in getCarouselImages" :key="index">
                        <img :src="image.url" class="carousel-image">
                    </div>
                </div>
                <!-- Add Pagination -->
                <div class="swiper-pagination"></div>
                <!-- Add Navigation -->
                <div class="swiper-button-next"></div>
                <div class="swiper-button-prev"></div>
            </div>

            <div class="container">
                <div class="products">
                    <div class="products-main-header">
                        <h2>{{ $t('productList') }}</h2>
                        <div class="products-main-header-buttons">
                            <button @click="openModal('orderHistory')">{{ $t('viewOrderHistory') }}</button>
                            <button @click="openModal('productManagement')">{{
                                $t('productManagement') }}</button>
                            <button @click="openModal('carouselManagement')">{{
                                $t('manageCarousel') }}</button>
                        </div>
                    </div>

                    <div class="products-list">
                        <div v-for="product in filteredProducts" :key="product.id" class="product-card"
                            :class="{ deleted: product.deleted }" itemscope itemtype="http://schema.org/Product">
                            <div class="product-header">
                                <h3 itemprop="name">{{ product.name }}</h3>
                            </div>
                            <div v-if="product.images && product.images.length > 0"
                                class="swiper-container product-swiper-container"
                                :class="'product-swiper-' + product.id">
                                <div class="swiper-wrapper">
                                    <div class="swiper-slide" v-for="(img, index) in product.images" :key="index">
                                        <img :src="img" alt="Product Image">
                                    </div>
                                </div>
                            </div>
                            <div v-else class="no-image-placeholder">
                                {{ $t('noImageAvailable') }}
                            </div>
                            <div itemprop="offers" itemscope itemtype="http://schema.org/Offer">
                                <p>{{ $t('price') }}: <span itemprop="price">{{ formattedPrice(product.price) }}</span>
                                </p>
                                <meta itemprop="priceCurrency" content="TWD" />
                            </div>
                            <p>{{ $t('stock') }}: <span itemprop="inventoryLevel">{{ product.stock }}</span></p>
                            <div itemprop="brand" itemscope itemtype="http://schema.org/Brand">
                                <p>{{ $t('brand') }}: <span itemprop="name">{{ product.brand || 'N/A' }}</span></p>
                            </div>
                            <div itemprop="aggregateRating" itemscope itemtype="http://schema.org/AggregateRating">
                                <p>{{ $t('rating') }}: <span itemprop="ratingValue">{{ product.rating || 'N/A' }}</span>
                                    (<span itemprop="reviewCount">0</span> reviews)</p>
                            </div>
                            <p>{{ $t('sold') }}: {{ product.soldQuantity }}</p>
                            <button @click="addToCart(product)" :disabled="product.stock === 0" class="add-to-cart-btn">
                                <i class="material-icons">add_shopping_cart</i>
                                <span>{{ $t('addToCart') }}</span>
                            </button>
                        </div>
                    </div>
                </div>

                <div class="cart">
                    <h2>{{ $t('cart') }}</h2>
                    <button v-if="cart.length > 0" @click="clearCart" class="remove-btn clear-cart-btn">{{
                        $t('clearCart') }}</button>
                    <div v-if="isAddingToEmptyCart" class="loading-overlay cart-loading-overlay">
                        <div class="spinner cart-spinner"></div>
                    </div>
                    <div v-if="cart.length === 0" class="empty-cart cart-content">
                        {{ $t('cartEmpty') }}
                    </div>
                    <div v-else class="cart-content">
                        <div class="cart-items-container">
                            <div v-for="item in cart" :key="item.id" class="cart-item">
                                <div>
                                    <strong>{{ item.name }}</strong>
                                    <br>
                                    <br>
                                    <small>{{ formattedPrice(item.price) }}</small>
                                </div>
                                <div class="quantity-controls">
                                    <button @click="updateQuantity(item, -1)">-</button>
                                    <span>{{ item.quantity }}</span>
                                    <button @click="updateQuantity(item, 1)">+</button>
                                </div>
                                <div>
                                    <button @click="removeFromCart(item.id)" class="icon-button remove-btn">
                                        <i class="material-icons">delete</i>
                                    </button>
                                </div>
                            </div>
                        </div>
                        <div class="cart-summary">
                            <div class="cart-summary-row">
                                <span>{{ $t('totalQuantity') }}:</span>
                                <span>{{ totalQuantity }}</span>
                            </div>
                            <div class="cart-summary-row">
                                <span>{{ $t('total') }}</span>
                                <span>{{ formattedPrice(cartTotal) }}</span>
                            </div>
                            <button @click="startCheckout" :disabled="cart.length === 0" class="checkout-btn">{{
                                $t('checkout') }}</button>
                        </div>
                    </div>
                </div>
            </div>

            <div v-if="currentModal && currentModal.name === 'checkout'" class="modal-overlay"
                :style="{ zIndex: getModalZIndex(modalStack.indexOf(currentModal)) }">
                <div class="modal-content">
                    <div class="modal-header">
                        <button @click="closeModal()" class="close-button" v-if="modalStack.length > 1"><i
                                class="material-icons">arrow_back</i></button>
                        <h2>{{ $t('checkout') }}</h2>
                        <button @click="closeModal()" class="close-button">&times;</button>
                    </div>
                    <div class="modal-body">
                        <h3>{{ $t('checkoutSummary') }}</h3>
                        <ul>
                            <li v-for="item in cart" :key="item.id">
                                {{ item.name }} x {{ item.quantity }} - {{ formattedPrice(item.price * item.quantity) }}
                            </li>
                        </ul>
                        <p><strong>{{ $t('total') }}: {{ formattedPrice(cartTotal) }}</strong></p>

                        <h3>{{ $t('choosePaymentMethod') }}</h3>
                        <div class="payment-methods">
                            <label class="payment-method-label">
                                <input type="radio" v-model="paymentMethod" value="credit_card"> {{ $t('creditCard') }}
                            </label>
                            <label class="payment-method-label">
                                <input type="radio" v-model="paymentMethod" value="line_pay"> {{ $t('linePay') }}
                            </label>
                            <label>
                                <input type="radio" v-model="paymentMethod" value="cash"> {{ $t('cash') }}
                            </label>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button @click="processCheckout">{{ $t('confirmCheckout') }}</button>
                        <button @click="closeModal()" class="remove-btn">{{ $t('cancel') }}</button>
                    </div>
                </div>
            </div>

            <div v-if="currentModal && currentModal.name === 'orderConfirmation'" class="modal-overlay"
                :style="{ zIndex: getModalZIndex(modalStack.indexOf(currentModal)) }">
                <div class="modal-content">
                    <div class="modal-header">
                        <button @click="closeModal()" class="close-button" v-if="modalStack.length > 1"><i
                                class="material-icons">arrow_back</i></button>
                        <h2>{{ $t('orderCreated') }}</h2>
                        <button @click="closeModal()" class="close-button">&times;</button>
                    </div>
                    <div class="modal-body">
                        <p>{{ $t('orderId') }}: <strong>{{ orderConfirmation.orderId }}</strong></p>
                        <p>{{ $t('total') }}: <strong>{{ formattedPrice(orderConfirmation.total) }}</strong></p>
                        <p>{{ $t('paymentMethod') }}: <strong>{{ $t(orderConfirmation.paymentMethod) }}</strong></p>
                        <h3>{{ $t('orderDetails') }}:</h3>
                        <ul>
                            <li v-for="item in orderConfirmation.items" :key="item.id">
                                {{ item.name }} x {{ item.quantity }} - {{ formattedPrice(item.price * item.quantity) }}
                            </li>
                        </ul>
                    </div>
                    <div class="modal-footer">
                        <button @click="closeModal()">{{ $t('close') }}</button>
                    </div>
                </div>
            </div>

            <div v-if="currentModal && currentModal.name === 'orderHistory'" class="modal-overlay"
                :style="{ zIndex: getModalZIndex(modalStack.indexOf(currentModal)) }">
                <div class="modal-content">
                    <div class="modal-header">
                        <button @click="closeModal()" class="close-button" v-if="modalStack.length > 1"><i
                                class="material-icons">arrow_back</i></button>
                        <h2>{{ $t('orderHistory') }}</h2>
                        <button @click="closeModal()" class="close-button">&times;</button>
                    </div>
                    <div v-if="orderHistory.length === 0" class="modal-body">
                        <p>{{ $t('noOrderHistory') }}</p>
                    </div>
                    <div v-else class="modal-body">
                        <div v-for="order in orderHistory" :key="order.orderId" class="order-history-card">
                            <h3>{{ $t('orderId') }}: {{ order.orderId }}</h3>
                            <p>{{ $t('date') }}: {{ new Date(order.timestamp).toLocaleString() }}</p>
                            <p>{{ $t('total') }}: {{ formattedPrice(order.total) }}</p>
                            <p>{{ $t('paymentMethod') }}: {{ $t(order.paymentMethod) }}</p>
                            <h4>{{ $t('orderDetails') }}:</h4>
                            <ul>
                                <li v-for="item in order.items" :key="item.id">
                                    {{ item.name }} x {{ item.quantity }} - {{ formattedPrice(item.price *
                                    item.quantity) }}
                                </li>
                            </ul>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button @click="closeModal()" class="remove-btn">{{ $t('closeOrderHistory') }}</button>
                    </div>
                </div>
            </div>





            <div v-if="currentModal && currentModal.name === 'editProductDetails'" class="modal-overlay"
                :style="{ zIndex: getModalZIndex(modalStack.indexOf(currentModal)) }">
                <div class="modal-content">
                    <div class="modal-header">
                        <button @click="closeModal()" class="close-button" v-if="modalStack.length > 1"><i
                                class="material-icons">arrow_back</i></button>
                        <h2>{{ $t('editProduct') }}</h2>
                        <button @click="closeModal()" class="close-button">&times;</button>
                    </div>
                    <div class="modal-body">
                        <p>{{ $t('productName') }}: <strong>{{ currentModal.data.product.name }}</strong></p>
                        <div class="form-group">
                            <label for="edit-product-name">{{ $t('productName') }}: </label>
                            <input type="text" id="edit-product-name" v-model="currentModal.data.newProductName"
                                class="form-input form-input-wide">
                        </div>
                        <div class="form-group">
                            <label for="edit-product-price">{{ $t('price') }}: </label>
                            <input type="number" id="edit-product-price"
                                v-model.number="currentModal.data.newProductPrice" min="0" class="form-input">
                        </div>
                        <div class="form-group">
                            <label for="edit-product-stock">{{ $t('stock') }}: </label>
                            <input type="number" id="edit-product-stock"
                                v-model.number="currentModal.data.newProductStock" min="0" class="form-input">
                        </div>
                        <div class="form-group">
                            <label for="edit-product-brand">{{ $t('brand') }}: </label>
                            <input type="text" id="edit-product-brand" v-model="currentModal.data.newProductBrand"
                                class="form-input form-input-wide">
                        </div>
                        <div class="form-group">
                            <label for="edit-product-image">{{ $t('imageUrl') }}: </label>
                            <input type="text" id="edit-product-image" v-model="currentModal.data.newProductImage"
                                class="form-input form-input-wide">
                        </div>
                        <div class="form-group">
                            <label for="stock-change-reason">{{ $t('reason') }}: </label>
                            <input type="text" id="stock-change-reason" v-model="currentModal.data.stockChangeReason"
                                :placeholder="$t('stockChangeReason')" class="form-input form-input-wide">
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button @click="confirmEditProductDetails">{{ $t('saveChanges') }}</button>
                        <button @click="closeModal()" class="remove-btn">{{ $t('cancel') }}</button>
                    </div>
                </div>
            </div>

            <div v-if="currentModal && currentModal.name === 'stockHistory'" class="modal-overlay"
                :style="{ zIndex: getModalZIndex(modalStack.indexOf(currentModal)) }">
                <div class="modal-content">
                    <div class="modal-header">
                        <button @click="closeModal()" class="close-button" v-if="modalStack.length > 1"><i
                                class="material-icons">arrow_back</i></button>
                        <h2>{{ $t('stockHistory') }} <span v-if="currentModal.data.product">- {{
                                currentModal.data.product.name }}</span></h2>
                        <button @click="closeModal()" class="close-button">&times;</button>
                    </div>
                    <div v-if="stockHistory.length === 0" class="modal-body">
                        <p>{{ $t('noStockHistory') }}</p>
                    </div>
                    <div v-else class="modal-body">
                        <div v-for="entry in stockHistory" :key="entry.id" class="stock-history-card">
                            <p><strong>{{ $t('date') }}:</strong> {{ new Date(entry.timestamp).toLocaleString() }}</p>
                            <p><strong>{{ $t('reason') }}:</strong> {{ entry.reason }}</p>
                            <p><strong>{{ $t('stock') }}:</strong> {{ entry.oldStock }} -> {{ entry.newStock }}</p>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button @click="closeModal()" class="remove-btn">{{ $t('close') }}</button>
                    </div>
                </div>
            </div>

            <div v-if="currentModal && currentModal.name === 'productManagement'" class="modal-overlay"
                :style="{ zIndex: getModalZIndex(modalStack.indexOf(currentModal)) }">
                <div class="modal-content">
                    <div class="modal-header">
                        <button @click="closeModal()" class="close-button" v-if="modalStack.length > 1"><i
                                class="material-icons">arrow_back</i></button>
                        <h2>{{ $t('productManagement') }}</h2>
                        <button @click="closeModal()" class="close-button">&times;</button>
                    </div>
                    <div class="modal-body">
                        <div class="add-product-section">
                            <h3>{{ $t('addProduct') }}</h3>
                            <div class="form-group-inline">
                                <input type="text" v-model="newProductName" :placeholder="$t('productName')"
                                    class="form-input">
                                <input type="number" v-model.number="newProductPrice" :placeholder="$t('price')"
                                    class="form-input">
                                <input type="number" v-model.number="newProductStock" :placeholder="$t('stock')"
                                    class="form-input">
                                <input type="text" v-model="newProductBrand" :placeholder="$t('brand')"
                                    class="form-input">
                                <input type="text" v-model="newProductImage" :placeholder="$t('imageUrl')"
                                    class="form-input">
                                <button @click="addNewProduct">{{ $t('addProduct') }}</button>
                                <button @click="generateRandomProduct">隨機生成產品</button>
                            </div>
                        </div>
                        <div class="products-list modal-products-list">
                            <div v-for="product in productsWithSoldQuantity" :key="product.id" class="product-card"
                                :class="{ deleted: product.deleted }" itemscope itemtype="http://schema.org/Product">
                                <div class="product-header">
                                    <h3 itemprop="name">{{ product.name }}</h3>
                                    <div class="product-actions dropdown">
                                        <button class="icon-button dropbtn">
                                            <i class="material-icons">more_vert</i>
                                        </button>
                                        <div class="dropdown-content">
                                            <a href="#"
                                                @click.prevent="openModal('editProductDetails', { product: product, newProductName: product.name, newProductPrice: product.price, newProductStock: product.stock, newProductBrand: product.brand, newProductImage: product.images.join(','), stockChangeReason: '', stockChanged: false })"><i
                                                    class="material-icons">edit</i> {{ $t('editProduct') }}</a>
                                            <a href="#" @click.prevent="viewStockHistory(product)"><i
                                                    class="material-icons">history</i> {{ $t('viewHistory') }}</a>
                                            <a v-if="!product.deleted" href="#"
                                                @click.prevent="deleteProduct(product)"><i
                                                    class="material-icons">delete</i> {{ $t('deleteProduct') }}</a>
                                            <a v-if="product.deleted" href="#"
                                                @click.prevent="restoreProduct(product)"><i
                                                    class="material-icons">restore</i> {{ $t('restore') }}</a>
                                        </div>
                                    </div>
                                </div>
                                <img itemprop="image" :src="product.image || 'https://via.placeholder.com/150'"
                                    alt="Product Image" style="display: none;">
                                <div itemprop="offers" itemscope itemtype="http://schema.org/Offer">
                                    <p>{{ $t('price') }}: <span itemprop="price">{{ formattedPrice(product.price)
                                            }}</span></p>
                                    <meta itemprop="priceCurrency" content="TWD" />
                                </div>
                                <p>{{ $t('stock') }}: <span itemprop="inventoryLevel">{{ product.stock }}</span></p>
                                <div itemprop="brand" itemscope itemtype="http://schema.org/Brand"
                                    style="display: none;">
                                    <span itemprop="name">{{ product.brand || 'N/A' }}</span>
                                </div>
                                <div itemprop="aggregateRating" itemscope itemtype="http://schema.org/AggregateRating"
                                    style="display: none;">
                                    <span itemprop="ratingValue">{{ product.rating || 'N/A' }}</span>
                                    <span itemprop="reviewCount">0</span>
                                </div>
                                <p>{{ $t('sold') }}: {{ product.soldQuantity }}</p>
                            </div>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button @click="closeModal()" class="remove-btn">{{ $t('closeProductManagement') }}</button>
                    </div>
                </div>
            </div>

            <div v-if="currentModal && currentModal.name === 'carouselManagement'" class="modal-overlay"
                :style="{ zIndex: getModalZIndex(modalStack.indexOf(currentModal)) }">
                <div class="modal-content">
                    <div class="modal-header">
                        <button @click="closeModal()" class="close-button" v-if="modalStack.length > 1"><i
                                class="material-icons">arrow_back</i></button>
                        <h2>{{ $t('manageCarousel') }}</h2>
                        <button @click="closeModal()" class="close-button">&times;</button>
                    </div>
                    <div class="modal-body">
                        <div class="add-image-section">
                            <h3>{{ $t('addImage') }}</h3>
                            <div class="form-group-inline">
                                <input type="text" v-model="newImageUrl" :placeholder="$t('imageUrl')"
                                    class="form-input form-input-wide">
                                <button @click="addCarouselImage">{{ $t('addImage') }}</button>
                            </div>
                        </div>
                        <div class="images-list">
                            <div v-for="(image, index) in carouselImages" :key="index" class="image-card">
                                <img :src="image.url" class="image-card-preview">
                                <button @click="removeCarouselImage(image)" class="remove-btn"><i
                                        class="material-icons">delete</i></button>
                            </div>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button @click="closeModal()" class="remove-btn">{{ $t('close') }}</button>
                    </div>
                </div>
            </div>

            <!-- Custom Alert/Confirm Modal -->
            <div v-if="notification.show" class="modal-overlay" style="z-index: 9999;">
                <div class="modal-content">
                    <div class="modal-header">
                        <h2>{{ notification.title }}</h2>
                    </div>
                    <div class="modal-body">
                        <p>{{ notification.message }}</p>
                    </div>
                    <div class="modal-footer">
                        <button v-if="notification.type === 'confirm'" @click="handleConfirmation(true)">{{
                            $t('confirm')
                            }}</button>
                        <button @click="handleConfirmation(false)"
                            :class="{ 'remove-btn': notification.type === 'confirm' }">{{
                            notification.type === 'confirm' ? $t('cancel') : $t('close') }}</button>
                    </div>
                </div>
            </div>
    </div>

    <script src="https://unpkg.com/swiper/swiper-bundle.min.js"></script>
    <!-- Vue 3 CDN -->
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <!-- Dexie.js (for IndexedDB) CDN -->
    <script src="https://unpkg.com/dexie@3/dist/dexie.js"></script>
    <!-- Vue I18n CDN -->
    <script src="https://unpkg.com/vue-i18n@9/dist/vue-i18n.global.js"></script>
    <!-- I18n Messages -->
    <script src="i18n.js"></script>

    <script>
        const { createApp, reactive } = Vue;
        const { createI18n } = VueI18n;

        const i18n = createI18n({
            locale: 'zh-TW', // 預設語言
            fallbackLocale: 'en-US',
            messages,
        });

        const app = createApp({
            data() {
                return {
                    products: [],
                    cart: [], // 購物車內容
                    db: null,    // IndexedDB instance
                    newProductName: '',
                    newProductPrice: null,
                    newProductStock: 0,
                    newProductBrand: '',
                    newProductImage: '',
                    productSwipers: {},
                    paymentMethod: 'credit_card', // 預設支付方式
                    orderConfirmation: null, // 儲存訂單確認資訊
                    orderHistory: [], // 儲存歷史訂單
                    isLoading: true, // 控制初始載入畫面
                    isProcessingOrder: false, // 控制結帳處理載入畫面
                    isAddingToEmptyCart: false, // 控制加入空購物車時的載入畫面
                    locale: 'zh-TW', // 預設語言為繁體中文
                    stockHistory: [],
                    carouselImages: [],
                    newImageUrl: '',
                    modalStack: [], // Centralized modal management
                    notification: {
                        show: false,
                        type: 'alert', // 'alert' or 'confirm'
                        title: '',
                        message: '',
                        onConfirm: null
                    }
                };
            },
            computed: {
                getCarouselImages() {
                    return this.carouselImages;
                },
                cartTotal() {
                    return this.cart.reduce((total, item) => total + (item.price * item.quantity), 0);
                },
                totalQuantity() {
                    return this.cart.reduce((total, item) => total + item.quantity, 0);
                },
                productsWithSoldQuantity() {
                    const soldQuantities = {};
                    this.orderHistory.forEach(order => {
                        order.items.forEach(item => {
                            soldQuantities[item.productId] = (soldQuantities[item.productId] || 0) + item.quantity;
                        });
                    });

                    return this.products.map(product => ({
                        ...product,
                        soldQuantity: soldQuantities[product.id] || 0
                    }));
                },
                filteredProducts() {
                    return this.productsWithSoldQuantity.filter(p => !p.deleted);
                },
                currentModal() {
                    return this.modalStack.length > 0 ? this.modalStack[this.modalStack.length - 1] : null;
                },
                showModalOverlay() {
                    return this.modalStack.length > 0;
                }
            },
            watch: {
                showModalOverlay(newValue) {
                    if (newValue) {
                        document.body.classList.add('modal-open');
                    } else {
                        document.body.classList.remove('modal-open');
                    }
                },
                'notification.show': function (newValue) {
                    if (newValue) {
                        document.body.classList.add('modal-open');
                    } else if (!this.showModalOverlay) { // Only remove if no other modals are open
                        document.body.classList.remove('modal-open');
                    }
                }
            },
            methods: {
                openModal(name, data = {}) {
                    this.modalStack.push({ name, data });
                },
                closeModal() {
                    this.modalStack.pop();
                },
                closeAllModals() {
                    this.modalStack = [];
                },
                getModalZIndex(index) {
                    return 1200 + index;
                },
                showAlert(message, title = 'Info') {
                    this.notification.type = 'alert';
                    this.notification.title = title;
                    this.notification.message = message;
                    this.notification.show = true;
                },
                showConfirm(message, title = 'Confirm') {
                    return new Promise((resolve) => {
                        this.notification.type = 'confirm';
                        this.notification.title = title;
                        this.notification.message = message;
                        this.notification.show = true;
                        this.notification.onConfirm = resolve;
                    });
                },
                handleConfirmation(isConfirmed) {
                    if (this.notification.onConfirm) {
                        this.notification.onConfirm(isConfirmed);
                    }
                    this.notification.show = false;
                    this.notification.onConfirm = null; // Reset for next time
                },
                generateUUID() {
                    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
                        var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
                        return v.toString(16);
                    });
                },
                formattedPrice(price) {
                    const locale = this.locale;
                    // Access messages from i18n.global directly, as it's now reactive
                    const localeConfig = i18n.global.messages[locale];

                    if (localeConfig && localeConfig.currencyFormat) {
                        const convertedPrice = price * (localeConfig.exchangeRate || 1);
                        const finalPrice = Number.isInteger(convertedPrice) ? convertedPrice : convertedPrice.toFixed(2);
                        return localeConfig.currencyFormat
                            .replace('{symbol}', localeConfig.currencySymbol || '')
                            .replace('{value}', finalPrice);
                    }
                    return `NT$${price}`;
                },
                async setupDatabase() {
                    this.db = new Dexie('ShoppingCartDB');
                    this.db.version(1).stores({
                        products: 'id, name, price, stock, brand, rating, images, deleted',
                        cart: '++id, &productId, name, price, quantity',
                        orders: '++id, orderId, total, paymentMethod, timestamp',
                        stockHistory: '++id, productId, timestamp, oldStock, newStock, reason',
                        carouselImages: '++id, &url'
                    }).upgrade(tx => {
                        // This upgrade function will run if the user has a database version < 85.
                        // It will migrate the 'image' property to an 'images' array.
                        return tx.table('products').toCollection().modify(product => {
                            if (product.image && !Array.isArray(product.images)) {
                                product.images = [product.image];
                                delete product.image;
                            }
                        });
                    });

                    await this.db.on('populate', (tx) => this.seedInitialData(tx));

                },
                async loadProducts() {
                    if (!this.db) return;
                    try {
                        this.products = await this.db.products.toArray();
                        this.initProductSwipers();
                    } catch (error) {
                        console.error("Could not load products from IndexedDB:", error);
                    }
                },
                async loadCart() {
                    if (!this.db) return;
                    try {
                        const cartItems = await this.db.cart.toArray();
                        this.cart = cartItems;
                    } catch (error) {
                        console.error("Could not load cart from IndexedDB:", error);
                    }
                },
                async addToCart(product) {
                    if (product.stock === 0) {
                        this.showAlert(this.$t('productSoldOut'));
                        return;
                    }

                    const wasCartEmpty = this.cart.length === 0;
                    if (wasCartEmpty) {
                        this.isAddingToEmptyCart = true;
                    }

                    try {
                        await this.db.transaction('rw', this.db.cart, async (trans) => {
                            const cartTable = trans.table('cart');
                            const existingItem = await cartTable.where('productId').equals(product.id).first();

                            if (existingItem) {
                                if (existingItem.quantity >= product.stock) {
                                    this.showAlert(this.$t('maxQuantityReached'));
                                    return;
                                }
                                await cartTable.update(existingItem.id, {
                                    quantity: existingItem.quantity + 1
                                });
                            } else {
                                await cartTable.add({
                                    productId: product.id,
                                    name: product.name,
                                    price: product.price,
                                    quantity: 1
                                });
                            }
                        });
                        await this.loadCart();

                        if (wasCartEmpty) {
                            await new Promise(resolve => setTimeout(resolve, 600));
                            this.isAddingToEmptyCart = false;
                        }

                    } catch (error) {
                        if (wasCartEmpty) {
                            this.isAddingToEmptyCart = false;
                        }
                        console.error("Error adding to cart:", error);
                    }
                },
                async removeFromCart(itemId) {
                    try {
                        await this.db.cart.delete(itemId);
                        await this.loadCart();
                    } catch (error) {
                        console.error("Error removing from cart:", error);
                    }
                },
                async updateQuantity(item, change) {
                    try {
                        const productInStock = this.products.find(p => p.id === item.productId);
                        const newQuantity = item.quantity + change;

                        if (change > 0 && productInStock && newQuantity > productInStock.stock) {
                            this.showAlert(this.$t('maxQuantityReached'));
                            return;
                        }

                        if (newQuantity === 0) {
                            const confirmed = await this.showConfirm(this.$t('confirmRemoveProduct', { productName: item.name }));
                            if (!confirmed) {
                                return; // User canceled the removal
                            }
                        }

                        await this.db.transaction('rw', this.db.cart, async (trans) => {
                            if (newQuantity <= 0) {
                                await trans.cart.delete(item.id);
                            } else {
                                await trans.cart.update(item.id, { quantity: newQuantity });
                            }
                        });
                        await this.loadCart();
                    } catch (error) {
                        console.error("Error updating quantity:", error);
                    }
                },
                async addNewProduct() {
                    if (this.newProductName && this.newProductPrice > 0) {
                        const newProduct = {
                            id: this.generateUUID(),
                            name: this.newProductName,
                            price: parseFloat(this.newProductPrice),
                            stock: this.newProductStock,
                            brand: this.newProductBrand || 'N/A',
                            rating: 'N/A',
                            images: this.newProductImage ? this.newProductImage.split(',').map(s => s.trim()) : [],
                            deleted: false
                        };
                        await this.db.products.add(newProduct);
                        await this.loadProducts();
                        this.newProductName = '';
                        this.newProductPrice = null;
                        this.newProductStock = 0;
                        this.newProductBrand = '';
                        this.newProductImage = '';
                    } else {
                        alert(this.$t('enterValidProduct'));
                    }
                },
                async generateRandomProduct() {
                    const randomNames = ['T恤', '牛仔褲', '運動鞋', '帽子', '背包', '手錶', '太陽眼鏡', '耳機', '鍵盤', '滑鼠'];
                    const randomName = randomNames[Math.floor(Math.random() * randomNames.length)] + '-' + Math.floor(Math.random() * 1000);
                    const randomPrice = parseFloat((Math.random() * 100 + 10).toFixed(2));
                    const randomStock = Math.floor(Math.random() * 100) + 1;
                    const randomBrand = ['Nike', 'Adidas', 'Puma', 'Sony', 'Apple'][Math.floor(Math.random() * 5)];
                    const randomRating = (Math.random() * 5).toFixed(1);

                    const newProduct = {
                        id: this.generateUUID(),
                        name: randomName,
                        price: randomPrice,
                        stock: randomStock,
                        brand: randomBrand,
                        rating: randomRating,
                        images: [],
                        deleted: false
                    };
                    await this.db.products.add(newProduct);
                    await this.loadProducts();
                },
                async seedInitialData() {
                    // This method is called within the populate transaction, so we don't need a new one.
                    // We can directly use this.db.products and this.db.carouselImages
                    const productsToSeed = [
                        {
                            id: this.generateUUID(), name: '高品質純棉T恤', price: 499, stock: 50, brand: 'Demo', rating: 4.5,
                            images: [],
                            deleted: false
                        },
                        {
                            id: this.generateUUID(), name: '經典款藍色牛仔褲', price: 1299, stock: 30, brand: 'Demo', rating: 4.8,
                            images: [],
                            deleted: false
                        },
                        {
                            id: this.generateUUID(), name: '無線藍牙降噪耳機', price: 2499, stock: 20, brand: 'Demo', rating: 4.9,
                            images: [],
                            deleted: false
                        }
                    ];
                    await this.db.products.bulkAdd(productsToSeed);

                        const carouselImagesToSeed = [
                            { url: 'https://cdn.pixabay.com/photo/2025/04/24/01/29/trees-9554109_1280.jpg' },
                            { url: 'https://cdn.pixabay.com/photo/2021/08/31/10/34/boat-shed-6588414_960_720.jpg' }]
                    await this.db.carouselImages.bulkAdd(carouselImagesToSeed);
                },
                async deleteProduct(product) {
                    if (confirm(this.$t('deleteConfirmation', { productName: product.name }))) {
                        try {
                            await this.db.transaction('rw', this.db.products, this.db.cart, async (trans) => {
                                await trans.products.update(product.id, { deleted: true });
                                await trans.cart.where('productId').equals(product.id).delete();
                            });
                            await this.loadProducts();
                            await this.loadCart();
                        } catch (error) {
                            console.error("Error deleting product:", error);
                            alert("Failed to delete product.");
                        }
                    }
                },
                async restoreProduct(product) {
                    try {
                        await this.db.transaction('rw', this.db.products, async (trans) => {
                            await trans.products.update(product.id, { deleted: false });
                        });
                        await this.loadProducts();
                    } catch (error) {
                        console.error("Error restoring product:", error);
                        alert("Failed to restore product.");
                    }
                },
                async clearCart() {
                    try {
                        await this.db.cart.clear();
                        await this.loadCart();
                    } catch (error) {
                        console.error("Error clearing cart:", error);
                    }
                },
                startCheckout() {
                    this.openModal('checkout');
                },
                async processCheckout() {
                    if (this.cart.length === 0) {
                        alert(this.$t('cartEmptyCheckout'));
                        return;
                    }

                    if (!this.paymentMethod) {
                        alert(this.$t('selectPaymentMethod'));
                        return;
                    }

                    for (const cartItem of this.cart) {
                        const product = this.products.find(p => p.id === cartItem.productId);
                        if (!product || product.stock < cartItem.quantity) {
                            alert(this.$t('insufficientStock', { productName: cartItem.name, stock: product ? product.stock : 0, quantity: cartItem.quantity }));
                            return;
                        }
                    }

                    try {
                        this.isProcessingOrder = true; // 開始處理訂單，顯示載入畫面

                        const orderId = `ORD-${Date.now()}-${Math.floor(Math.random() * 1000)}`;
                        const order = {
                            orderId: orderId,
                            total: this.cartTotal,
                            paymentMethod: this.paymentMethod,
                            timestamp: new Date().toISOString(),
                            items: this.cart.map(item => ({ ...item })) // 複製購物車商品，避免引用問題
                        };

                        await this.db.transaction('rw', this.db.orders, this.db.products, this.db.cart, this.db.stockHistory, async (trans) => {
                            await trans.orders.add(order);

                            // 減少商品庫存並記錄歷史
                            for (const cartItem of this.cart) {
                                const productInDb = await trans.products.get(cartItem.productId); // Get product from DB within transaction
                                if (productInDb) {
                                    const oldStock = productInDb.stock; // Use stock from DB
                                    const newStock = oldStock - cartItem.quantity;
                                    await trans.products.update(productInDb.id, { stock: newStock });
                                    await trans.stockHistory.add({
                                        productId: productInDb.id,
                                        timestamp: new Date().toISOString(),
                                        oldStock,
                                        newStock,
                                        reason: `Order ${orderId}`
                                    });
                                }
                            }

                            await trans.cart.clear(); // 清空購物車
                        });

                        await this.loadProducts();
                        await this.loadCart();
                        await this.loadOrderHistory();

                        await new Promise(resolve => setTimeout(resolve, 1000));

                        this.isProcessingOrder = false; // 處理完成，關閉載入畫面
                        this.orderConfirmation = order; // 顯示訂單確認資訊
                        this.closeModal(); // Close checkout modal
                        this.openModal('orderConfirmation', order); // Open order confirmation modal
                        alert(this.$t('checkoutSuccess'));

                    } catch (error) {
                        this.isProcessingOrder = false; // 處理失敗，關閉載入畫面
                        console.error("Error processing checkout:", error);
                        alert(this.$t('checkoutFailed'));
                    }
                },
                async toggleOrderHistory() {
                    await this.loadOrderHistory();
                    this.openModal('orderHistory');
                },
                async loadOrderHistory() {
                    if (!this.db) return;
                    try {
                        this.orderHistory = await this.db.orders.toArray();
                        this.orderHistory.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
                    } catch (error) {
                        console.error("Could not load order history from IndexedDB:", error);
                    }
                },
                startEditStock(product) {
                    this.openModal('editStock', { product: { ...product }, newStock: product.stock, stockChangeReason: '' });
                },
                async confirmEditProductDetails() {
                    const product = this.currentModal.data.product;
                    const newProductName = this.currentModal.data.newProductName;
                    const newProductPrice = parseFloat(this.currentModal.data.newProductPrice);
                    const newProductStock = parseInt(this.currentModal.data.newProductStock);
                    const newProductBrand = this.currentModal.data.newProductBrand;
                    const newProductImages = this.currentModal.data.newProductImage ? this.currentModal.data.newProductImage.split(',').map(s => s.trim()) : [];
                    const stockChangeReason = this.currentModal.data.stockChangeReason;

                    if (!newProductName || isNaN(newProductPrice) || newProductPrice <= 0 || isNaN(newProductStock) || newProductStock < 0) {
                        this.showAlert(this.$t('enterValidProduct'));
                        return;
                    }

                    const oldStock = product.stock;
                    const stockChanged = newProductStock !== oldStock;

                    if (stockChanged && !stockChangeReason) {
                        this.showAlert(this.$t('reasonRequired'));
                        return;
                    }

                    try {
                        await this.db.transaction('rw', this.db.products, this.db.cart, this.db.stockHistory, async (trans) => {
                            await trans.products.update(product.id, {
                                name: newProductName,
                                price: newProductPrice,
                                stock: newProductStock,
                                brand: newProductBrand,
                                images: newProductImages
                            });

                            // Update cart items with new product name and price
                            const cartItemsToUpdate = await trans.cart.where('productId').equals(product.id).toArray();
                            for (const cartItem of cartItemsToUpdate) {
                                await trans.cart.update(cartItem.id, { name: newProductName, price: newProductPrice });
                            }

                            if (stockChanged) {
                                await trans.stockHistory.add({
                                    productId: product.id,
                                    timestamp: new Date().toISOString(),
                                    oldStock,
                                    newStock: newProductStock,
                                    reason: stockChangeReason
                                });
                            }
                        });
                        await this.loadProducts();
                        await this.loadCart(); // Reload cart to reflect changes
                        this.closeModal();
                    } catch (error) {
                        console.error("Error confirming product details edit:", error); // Log the full error object
                        this.showAlert(`${this.$t('checkoutFailed')} ${error.message || error}`); // Display more specific error
                    }
                },
                cancelEditStock() {
                    this.closeModal();
                },
                async viewStockHistory(product) {
                    if (!this.db) return;
                    this.stockHistory = []; // Clear previous history
                    try {
                        const history = await this.db.stockHistory.where('productId').equals(product.id).toArray();
                        this.stockHistory = history.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
                        this.openModal('stockHistory', { product: product });
                    } catch (error) {
                        console.error("Could not load stock history from IndexedDB:", error);
                        this.showAlert("Failed to load stock history.");
                    }
                },
                async logStockChange(productId, oldStock, newStock, reason) {
                    if (!this.db) return;
                    try {
                        await this.db.stockHistory.add({
                            productId,
                            timestamp: new Date().toISOString(),
                            oldStock,
                            newStock,
                            reason
                        });
                    } catch (error) {
                        console.error("Error logging stock change:", error);
                    }
                },
                async loadCarouselImages() {
                    if (!this.db) return;
                    try {
                        this.carouselImages = await this.db.carouselImages.toArray();
                    } catch (error) {
                        console.error("Could not load carousel images from IndexedDB:", error);
                    }
                },
                initSwiper() {
                    this.$nextTick(() => {
                        if (this.swiper) {
                            this.swiper.destroy(true, true);
                        }
                        this.swiper = new Swiper('.main-carousel', {
                            loop: true,
                            pagination: {
                                el: '.swiper-pagination',
                                clickable: true,
                            },
                            navigation: {
                                nextEl: '.swiper-button-next',
                                prevEl: '.swiper-button-prev',
                            },
                            autoplay: {
                                delay: 3000,
                                disableOnInteraction: false,
                            },
                        });
                    });
                },
                initProductSwipers() {
                    this.$nextTick(() => {
                        this.products.forEach(product => {
                            const swiperSelector = `.product-swiper-${product.id}`;
                            if (this.productSwipers[product.id]) {
                                this.productSwipers[product.id].destroy(true, true);
                            }
                            this.productSwipers[product.id] = new Swiper(swiperSelector, {
                                observer: true,
                                observeParents: true,
                            });
                        });
                    });
                },
                async addCarouselImage() {
                    if (!this.newImageUrl) return;

                    const existing = this.carouselImages.some(img => img.url === this.newImageUrl);
                    if (existing) {
                        alert(this.$t('imageExists'));
                        return;
                    }

                    const newImage = { url: this.newImageUrl };
                    const originalUrl = this.newImageUrl;

                    // 1. Optimistic UI Update
                    this.carouselImages.push(newImage);
                    this.newImageUrl = '';
                    this.initSwiper();

                    // 2. Call the dedicated DB method
                    try {
                        await this._dbAddImage(newImage);
                    } catch (error) {
                        console.error("Error adding carousel image to DB:", error);
                        // 3. Revert UI on failure
                        const index = this.carouselImages.findIndex(img => img.url === newImage.url);
                        if (index !== -1) {
                            this.carouselImages.splice(index, 1);
                        }
                        this.newImageUrl = originalUrl;
                        this.initSwiper();
                        alert(this.$t('dbErrorReverted'));
                    }
                },

                async removeCarouselImage(image) {
                    const index = this.carouselImages.findIndex(img => img.url === image.url);
                    if (index === -1) return;

                    try {
                        await this._dbRemoveImage(image.url);

                        // Update UI only after successful DB operation
                        this.carouselImages.splice(index, 1);
                        this.initSwiper();
                    } catch (error) {
                        console.error("Error removing carousel image from DB:", error);
                        alert('Failed to remove image.');
                    }
                },

                // --- Dedicated DB Methods ---
                _dbAddImage(image) {
                    return this.db.transaction('rw', this.db.carouselImages, async (trans) => {
                        const carouselImagesTable = trans.table('carouselImages');
                        await carouselImagesTable.add(image);
                    });


                },
                _dbRemoveImage(url) {
                    return this.db.transaction('rw', this.db.carouselImages, async (trans) => {
                        const carouselImagesTable = trans.table('carouselImages');
                        await carouselImagesTable.where('url').equals(url).delete();
                    });
                },

                async fetchExchangeRates() {
                    const BASE_CURRENCY = 'TWD';
                    const API_URL = `https://h-web-api-a2gvavdbg9dggxa3.canadacentral-01.azurewebsites.net/api/Toolbox/ProxyAPI?Url=https%3A%2F%2Fv6.exchangerate-api.com%2Fv6%2Fa80efb83a09fb6489e1e5034%2Flatest%2F${BASE_CURRENCY}`;

                    try {
                        const response = await fetch(API_URL);
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        const data = await response.json();
                        const dataParse = JSON.parse(data.data);
                        const messages = i18n.global.messages;

                        if (dataParse) {
                            for (const localeKey in messages) { // Use reactiveMessages
                                if (messages[localeKey].currencySymbol) { // Use reactiveMessages
                                    const targetCurrency = messages[localeKey].currencySymbol.replace(/[^a-zA-Z]/g, ''); // Extract currency code from symbol
                                    if (dataParse.conversion_rates[targetCurrency]) {
                                        messages[localeKey].exchangeRate = dataParse.conversion_rates[targetCurrency]; // Update reactiveMessages
                                    } else {
                                        console.warn(`Exchange rate for ${targetCurrency} not found in API response.`);
                                        messages[localeKey].exchangeRate = 1; // Fallback to 1 if not found
                                    }
                                }
                            }
                            console.log("Exchange rates updated successfully!");
                            // No need to re-initialize i18n or set locale messages explicitly here
                            // Vue's reactivity system will handle updates to reactiveMessages
                        } else {
                            console.error("API response does not contain conversion_rates.", data);
                        }
                    } catch (error) {
                        console.error("Failed to fetch exchange rates:", error);
                        // Fallback to default exchange rates (1 for TWD, others as previously defined in i18n.js if not updated)
                        // For simplicity, we'll just log the error. In a real app, you might want to set specific fallbacks.
                    }
                },
            },
            async created() {
                this.setupDatabase();
                try {
                    await this.db.open();
                    // Now that the DB is open (and populated if it was the first time), load all data.
                    await Promise.all([
                        this.loadProducts(),
                        this.loadCart(),
                        this.loadOrderHistory(),
                        this.loadCarouselImages(),
                        this.fetchExchangeRates()
                    ]);
                    this.initSwiper();
                } catch (error) {
                    console.error("Failed to initialize the application:", error);
                    this.showAlert('Failed to load database. Please try refreshing.', 'Initialization Error');
                } finally {
                    this.isLoading = false;
                }
            }
        });



        // Initialize i18n with the reactive messages
        // const i18n = createI18n({
        //     locale: 'zh-TW', // 預設語言
        //     fallbackLocale: 'en-US',
        //     messages: reactiveMessages, // Use the reactive messages object
        // });

        app.use(i18n);
        app.mount('#app');
    </script>

    <footer>
        <div class="footer-content">
            <h3>公司資訊</h3>
            <p>公司名稱：Gemini CLI 商店</p>
            <p>地址：模擬地址，模擬城市，模擬國家</p>
            <p>電話：(02) 1234-5678</p>
            <p>電子郵件：info@geminicli.com</p>
        </div>
        <div class="footer-content">
            <h3>更新資訊</h3>
            <p>最後更新日期：2025年7月4日</p>
            <p>版本：1.0.0</p>
        </div>
        <div class="footer-content">
            <details>
                <summary>無障礙標籤與聲明</summary>
                <p>本網站致力於提供無障礙的瀏覽體驗。我們遵循無障礙網頁內容指南 (WCAG) 2.1 AA 級標準。</p>
                <p>如果您在使用本網站時遇到任何無障礙問題，請聯繫我們。</p>
                <ul>
                    <li>鍵盤導航支援</li>
                    <li>高對比模式支援</li>
                    <li>螢幕閱讀器優化</li>
                </ul>
            </details>
        </div>
        <div class="footer-bottom">
            <p>&copy; 2025 Gemini CLI 商店. All rights reserved.</p>
        </div>
    </footer>
</body>

</html>